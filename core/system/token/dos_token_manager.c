/*©mit**************************************************************************
*                                                                              *
* This file is part of FRIEND UNIFYING PLATFORM.                               *
* Copyright 2014-2017 Friend Software Labs AS                                  *
*                                                                              *
* Permission is hereby granted, free of charge, to any person obtaining a copy *
* of this software and associated documentation files (the "Software"), to     *
* deal in the Software without restriction, including without limitation the   *
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or  *
* sell copies of the Software, and to permit persons to whom the Software is   *
* furnished to do so, subject to the following conditions:                     *
*                                                                              *
* The above copyright notice and this permission notice shall be included in   *
* all copies or substantial portions of the Software.                          *
*                                                                              *
* This program is distributed in the hope that it will be useful,              *
* but WITHOUT ANY WARRANTY; without even the implied warranty of               *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
* MIT License for more details.                                                *
*                                                                              *
*****************************************************************************©*/
/** @file
 *
 * Body of DOS token manager
 *
 * @author PS (Pawel Stefansky)
 * @date created PS (27/03/2018)
 */

#include "dos_token_manager.h"
#include <util/session_id.h>
#include <system/systembase.h>

/**
 * Create DOSTokenManager
 *
 * @param sb pointer to SystemBase
 * @return new instance of DOSTokenManager
 */
DOSTokenManager *DOSTokenManagerNew( void *sb )
{
	DOSTokenManager *dtm = FCalloc( 1, sizeof( DOSTokenManager ) );
	if( dtm != NULL )
	{
		dtm->dtm_SB = sb;
		pthread_mutex_init( &dtm->dtm_Mutex, NULL );
	}
	return dtm;
}

/**
 * Release DOSTokenManager
 *
 * @param pointer to DOSTokenManager which will be deleted
 */
void DOSTokenManagerDelete( DOSTokenManager *d )
{
	if( d != NULL )
	{
		DOSTokenDeleteAll( d->dtm_Tokens );
		
		pthread_mutex_destroy( &d->dtm_Mutex );
		
		FFree( d );
	}
}

/**
 * Add DOSToken to tokens list
 *
 * @param d pointer to DOSTokenManager
 * @param dt pointer to DOSToken which will be added to list
 * @return 0 when success, otherwise error number
 */
int DOSTokenManagerAddDOSToken( DOSTokenManager *d, DOSToken *dt )
{
	if( d != NULL && dt != NULL )
	{
		pthread_mutex_lock( &d->dtm_Mutex );
		
		dt->node.mln_Succ = (MinNode *)d->dtm_Tokens;
		d->dtm_Tokens = dt;
		
		pthread_mutex_unlock( &d->dtm_Mutex );
		
		return 0;
	}
	return 1;
}

/**
 * Get DOSToken from tokens list
 *
 * @param d pointer to DOSTokenManager
 * @param tokenID token ID as string
 * @return pointer to DOSToken structure wheen success, otherwise NULL
 */
DOSToken *DOSTokenManagerGetDOSToken( DOSTokenManager *d, const char *tokenID )
{
	DOSToken *dt = NULL;
	
	if( d != NULL )
	{
		pthread_mutex_lock( &d->dtm_Mutex );
		
		dt = d->dtm_Tokens;
		
		while( dt != NULL )
		{
			DOSToken *remToken = NULL;
			
			// if token was found we are checking how many times it was used
			if( dt->ct_UsedTimes != 0 && strcmp( tokenID, dt->ct_TokenID ) == 0 )
			{
				if( dt->ct_UsedTimes > 0 )
				{
					dt->ct_UsedTimes--;
				
					if( dt->ct_UsedTimes == 0 )
					{
						// entry will be removed when DOSTokenManagerAutoDelete will be called
					}
					else
					{
						break;
					}
				}
				else	// if -1 -> infinity
				{
					break;
				}
			}
			dt = (DOSToken *)dt->node.mln_Succ;
		}
		
		// if DOSToken was found
		// we can check if user session is attached
		
		if( dt != NULL )
		{
			if( dt->ct_UserSession == NULL )
			{
				UserSession *us = UserSessionNew( NULL, "autogenerated" );
				if( us != NULL )
				{
					us->us_SessionID = session_id_generate();
					us->us_LoggedTime = time( NULL );
					us->us_SB = d->dtm_SB;
					
					SystemBase *sb = (SystemBase *) us->us_SB;
					SQLLibrary *sqllib  = sb->LibrarySQLGet( sb );
					if( sqllib != NULL )
					{
						int error = 0;

						if( ( error = sqllib->Save( sqllib, UserSessionDesc, us ) ) != 0 )
						{
							FERROR("Cannot store session\n");
							
							/*
							if( ( loggedSession = USMUserSessionAdd( l->sl_USM, loggedSession ) ) != NULL )
						{
							if( loggedSession->us_User == NULL )
							{
							 */
						}
						else
						{
							DEBUG("[USMSessionSaveDB] Session stored\n");
						}
						sb->LibrarySQLDrop( sb, sqllib );
					}
				}
			}
		}
		
		pthread_mutex_unlock( &d->dtm_Mutex );
	}
	
	return dt;
}

/**
 * List all tokens (as JSON)
 *
 * @param dtm pointer to DOSTokenManager
 * @return new BufferedString with DOSTokens in json format
 */
BufString *DOSTokenManagerList( DOSTokenManager *dtm )
{
	int pos = 0;
	BufString *bs = BufStringNew();
	
	DOSToken *dt = NULL;
	
	if( dtm != NULL )
	{
		pthread_mutex_lock( &dtm->dtm_Mutex );
		
		BufStringAddSize( bs, "ok<!--separate-->[", 18 );
		
		dt = dtm->dtm_Tokens;
		while( dt != NULL )
		{
			if( pos > 0 )
			{
				BufStringAddSize( bs, ",", 1 );
				DOSTokenJSONDescription( dt, bs );
			}
			
			pos++;
			dt = (DOSToken *)dt->node.mln_Succ;
		}
		
		BufStringAddSize( bs, "]", 1 );
		
		pthread_mutex_unlock( &dtm->dtm_Mutex );
	}
	return bs;
}

/**
 * Erase UserSession from DOSToken
 *
 * @param dtm pointer to DOSTokenManager
 * @param s pointer to UserSession which will be erased from DOSToken
 * @return 0 when success, otherwise error number
 */
int DOSTokenManagerEraseUserSession( DOSTokenManager *dtm, UserSession *s )
{
	DOSToken *dt = NULL;
	
	if( dtm != NULL )
	{
		pthread_mutex_lock( &dtm->dtm_Mutex );
		
		dt = dtm->dtm_Tokens;
		
		while( dt != NULL )
		{
			if( dt->ct_UserSession == s )
			{
				dt->ct_UserSession = NULL;
				dt->ct_UserSessionID = 0;
				pthread_mutex_unlock( &dtm->dtm_Mutex );
				return 0;
			}
			dt = (DOSToken *)dt->node.mln_Succ;
		}
		
		pthread_mutex_unlock( &dtm->dtm_Mutex );
	}
	return 1;
}

/**
 * Remove obsolete DOSTokens
 *
 * @param d pointer to DOSTokenManager
 */
void DOSTokenManagerAutoDelete( DOSTokenManager *d )
{
	if( d != NULL )
	{
		pthread_mutex_lock( &d->dtm_Mutex );
		time_t now = time( NULL );
		
		DOSToken *newTokenList = NULL;
		
		DOSToken *dt = d->dtm_Tokens;
		
		while( dt != NULL )
		{
			DOSToken *oldToken = NULL;
			FBOOL remove = FALSE;
			
			// if token is not valid, we remove it
			
			if( now >= dt->ct_Timeout || dt->ct_UsedTimes == 0 )
			{
				remove = TRUE;
			}
			
			oldToken = dt;
			dt = (DOSToken *)dt->node.mln_Succ;
			
			if( remove == TRUE )
			{
				DOSTokenDelete( oldToken );
			}
			else
			{
				oldToken->node.mln_Succ = (MinNode *)newTokenList;
				newTokenList = oldToken;
			}
		}
		
		d->dtm_Tokens = newTokenList;
		
		pthread_mutex_unlock( &d->dtm_Mutex );
	}
}

